{
  "name": "each",
  "version": "0.1.1",
  "description": "Chained and parallel async iterator in one elegant function",
  "author": {
    "name": "David Worms",
    "email": "david@adaltas.com"
  },
  "contributors": [
    {
      "name": "David Worms",
      "email": "david@adaltas.com"
    }
  ],
  "scripts": {
    "test": "make test"
  },
  "dependencies": {
    "coffee-script": "latest"
  },
  "devDependencies": {
    "should": "latest",
    "mocha": "latest"
  },
  "engines": {
    "node": ">= 0.4.0"
  },
  "keywords": [
    "control flow",
    "asynchronous",
    "array",
    "object",
    "each"
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/wdavidw/node-each.git"
  },
  "readme": "[![Build Status](https://secure.travis-ci.org/wdavidw/node-each.png)](http://travis-ci.org/wdavidw/node-each)\n\n<pre style=\"font-family:courier\">\n _   _           _        ______           _     \n| \\ | |         | |      |  ____|         | |    \n|  \\| | ___   __| | ___  | |__   __ _  ___| |__  \n| . ` |/ _ \\ / _` |/ _ \\ |  __| / _` |/ __| '_ \\ \n| |\\  | (_) | (_| |  __/ | |___| (_| | (__| | | |\n|_| \\_|\\___/ \\__,_|\\___| |______\\__,_|\\___|_| |_| New BSD License\n</pre>\n\nNode Each is a single elegant function to iterate asynchronously over elements \nboth in `sequential`, `parallel` and `concurrent` mode.\n\nInstalling\n----------\n\nVia git (or downloaded tarball):\n\n```bash\n    git clone http://github.com/wdavidw/node-each.git\n```\n\nThen, simply copy or link the project inside a discoverable Node directory \n(eg './node_modules').\n\nVia [npm](http://github.com/isaacs/npm):\n\n```bash\n    npm install each\n```\n\nQuick example\n-------------\n\nThe following code traverse an array in `sequential` mode.\n\n```javascript\nvar each = require('each');\neach( [{id: 1}, {id: 2}, {id: 3}] )\n.on('item', function(next, element, index) {\n    console.log('element: ', element, '@', index);\n    setTimeout(next, 500);\n})\n.on('both', function(err) {\n    if(err){\n        console.log(err.message);\n    }else{\n        console.log('Done');\n    }\n});\n```\n\nOr alternatively using the `error` and `end` events:\n\n```javascript\nvar each = require('each');\neach( [{id: 1}, {id: 2}, {id: 3}] )\n.on('item', function(next, element, index) {\n    console.log('element: ', element, '@', index);\n    setTimeout(next, 500);\n})\n.on('error', function(err) {\n    console.log(err.message);\n})\n.on('end', function() {\n    console.log('Done');\n});\n```\n\nAPI\n---\n\nThe `each` function signature is: `each(subject)`. \n\n-   `subject`   \n    The subject to iterate. It can be an array, an object or \n    any other types in which case the behavior is similar to the one of an array.\n\nThe return object is an instance of `EventEmitter`.\n\nThe following properties and functions are available:\n\n-   `parallel`   \n    The second argument is optional and indicate wether or not you want the \n    iteration to run in `sequential`, `parallel` or `concurrent` mode. See below\n    for more details about the different modes.\n-   `paused`\n    Indicate the state of the current event emitter\n-   `readable`\n    Indicate if the stream will emit more event\n\nThe following events are send:\n\n-   `item`   \n    Called for each iterated element. The arguments depends on the \n    subject type.\n    The first argument, `next`, is a function to call at the end of your \n    callback. It may be called with an error instance to trigger the `error` event.\n    For objects, the second and third arguments are the key and value \n    of each elements. For anything else, the second and third arguments are the \n    value and the index (starting at 0) of each elements.\n-   `error`   \n    Called only if an error occured. The iteration will be stoped on error meaning\n    no `item` event will be called other than the ones already provisionned. Recieves\n    an error object as its first argument and eventually a second argument. See \n    the `dealing with errors` section for more information.\n-   `end`   \n    Called only if all the callback have been handled successfully. No argument is \n    provided in the callback.\n-   `both`   \n    Called only once all the items have been handled. It is a conveniency event\n    combining the `error` and `end` event in one call. Return the same arguments \n    than the `error` or `end` events depending on the operation outturn.\n\nParallelization modes\n---------------------\n\n-   `sequential`   \n    Parallel is `false` or set to `1`, default if no parallel mode is defined.\n    Callbacks are chained meaning each callback is called once the previous \n    callback is completed (after calling the `next` function argument).\n-   `parallel`\n    Parallel is `true`.\n    All the callbacks are called at the same time and run in parallel.\n-   `concurrent`\n    Parallel is an integer.\n    Only the defined number of callbacks is run in parallel.\n\nDealing with errors\n-------------------\n\nError are declared by calling `next` argument in the `item` event with an error \nobject as its first argument. An event `error` will be triggered and the \niteration will be stoped. Note that in case of parallel and concurrent mode, \nthe current callbacks are not canceled but no new element will be send to the \n`item` event.\n\nThe first element send to the `error` event is an error instance. In \n`sequential` mode, it is the event sent in the previous item `callback`. In \n`parallel` and `concurrent` modes, the second argument is an array will all \nthe error sent since multiple errors may be thrown at the same time.\n\nTraversing an array\n-------------------\n\nIn `sequential` mode:\n\nSee the \"Quick example\" section.\n\nIn `parallel` mode:\n\n```javascript\nvar each = require('each');\neach( [{id: 1}, {id: 2}, {id: 3}] )\n.parallel( true )\n.on('item', function(next, element, index) {\n    console.log('element: ', element, '@', index);\n    setTimeout(next, 500);\n})\n.on('error', function(err, errors){\n    console.log(err.message);\n    errors.forEach(function(error){\n        console.log('  '+error.message);\n    });\n})\n.on('end', function(){\n    console.log('Done');\n});\n```\n\nIn `concurrent` mode with 4 parallel executions:\n\n```javascript\nvar each = require('each');\neach( [{id: 1}, {id: 2}, {id: 3}] )\n.parallel( 4 )\n.on('item', function(next, element, index) {\n    console.log('element: ', element, '@', index);\n    setTimeout(next, 500);\n})\n.on('error', function(err, errors){\n    console.log(err.message);\n    errors.forEach(function(error){\n        console.log('  '+error.message);\n    });\n})\n.on('end', function(){\n    console.log('Done');\n});\n```\n\nTraversing an object\n--------------------\n\nIn `sequential` mode:\n\n```javascript\nvar each = require('each');\neach( {id_1: 1, id_2: 2, id_3: 3} )\n.on('item', function(next, key, value) {\n    console.log('key: ', key);\n    console.log('value: ', value);\n    setTimeout(next, 500);\n})\n.on('error', function(err) {\n    console.log(err.message);\n})\n.on('end', function() {\n    console.log('Done');\n});\n```\n\nIn `concurrent` mode with 2 parallels executions\n\n```javascript\nvar each = require('each');\neach( {id_1: 1, id_2: 2, id_3: 3} )\n.parallel( 2 )\n.on('item', function(next, key, value) {\n    console.log('key: ', key);\n    console.log('value: ', value);\n    setTimeout(next, 500);\n})\n.on('error', function(err, errors){\n    console.log(err.message);\n    errors.forEach(function(error){\n        console.log('  '+error.message);\n    });\n})\n.on('end', function(){\n    console.log('Done');\n});\n```\n\nReadable Stream\n---------------\n\nThe deferred object return by each partially implement the Node Readable Stream \nAPI. It can be used to throttle the iteration with the `pause` and `resume` \nfunctions or to pipe the result to a writeable stream in which case it is your\nresponsibility to emit the `data` event.\n\n```javascript\nvar fs = require('fs');\nvar each = require('each');\n\nvar eacher = each( {id_1: 1, id_2: 2, id_3: 3} )\n.parallel(2)\n.on('item', function(next, key, value) {\n    setTimeout(function(){\n        eacher.emit('data', key + ',' + value + '\\n');\n        next();\n    }, 100);\n})\n.on('end', function(){\n    console.log('Done');\n});\n\neacher.pipe(\n    fs.createWriteStream(__dirname + '/out.csv', { flags: 'w' })\n);\n```\n\nTesting\n-------\n\nRun the samples:\n\n```bash\nnode samples/array_concurrent.js\nnode samples/array_parallel.js\nnode samples/array_sequential.js\nnode samples/object_concurrent.js\nnode samples/object_sequential.js\nnode samples/readable_stream.js\n```\n\nRun all the tests:\n\n```bash\nmake test\n```\n\n    \n\n",
  "_id": "each@0.1.1",
  "dist": {
    "shasum": "712766e0084069c615275321a7ed5a9c83abd720"
  },
  "_from": "each"
}
